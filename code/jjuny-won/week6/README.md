# 6주차 README


- 이번 유형은 식을 만들어내는게 너무 어려워서 여러가지 블로그 참고해 이해한 것을 정리하였습니다.

## 1. 평범한 배낭(boj_12865)

## 문제
- 필요한 물건 N개
- 무게 W, 가치 V
- 해당 물건을 가면 V 만큼 즐길 수 있다
- 최대 K 만큼의 무게만을 넣을 수 있는 가방을 들고 다닐 수 있다
- 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값

### 입력
- 물품의 수 N, 버틸 수 있는 무게 K
- 2~N 즐까지 물건의 무게 W, V

### 출력
- 배낭에 넣을 수 있는 물건들의 가치합의 최댓값

### 접근 방법
- 뮬건을 하나씩 추가했을 배낭 무게의 최대 가치를 구했다
- dp[i] : 배낭 무개가 i 일 떄의 최대 가치를 저장하기 위한 배열
- dp[i-w]+v : 현재 보석을 배낭에 넣을 떄가의 가치(이전 무게 i-w 일 떄 최대 가치에 현재 가치 추가)
- max(dp[i],dp[i-w+v]) 식을 통해 현재 무게 i 일 떄 최대 가치를 얻음

### 아쉬웠던 점
- dp를 일차원으로 만들어서 풀었지만, 문제 풀이를 이해하다보니 2차원 배열로 만드는 방법도 있을 것 같다
- 이 식만 봐서도 이해가 어려워 직접 그리고 코드를 적으며 이해했다
- 지금은 이해해도 시간이 지나면 코드는 떠올리지 못할 것 같댜... (너무 어려움)


--- 

## 2. 합분해 (boj_2225)

### 문제
- 0 부터 N 까지의 정수 K 개를 더해 그 합이 N 이 되는 경우의 수를 구하는 프로그램
- 덧셈의 순서가 바뀐 경우는 다른 경우로 센다
- 한 개의 수를 여러번 쓸 수 있다

### 입출력
- 입력 : N, K
- 출력 : 경우의 수

### 접근 방법
- 표를 만들어해보니 점화식 dp[n][k] = dp[n][k-1] + dp[n-1][k] 를 확인할 수 있었다 

### 아쉬웠던 점
- 문제를 처음 접근할 떄 재귀로 해야하나, 피보나치 수열 처럼 구현해야하나 생각했다
- 그래서 접화식을 찾는데 더 어려움이 었었던 것 같다
- 지금까지 문제를 풀며 다이나믹은 표로 정리를 해서 점화식을 찾는 다는 것을 알게 되었다

---

## 3. N으로 표현 (prog_42895) -> 미해결

### 문제
- N, number 가 주어질 때, N 과 사칙연산만 사용해서 표현할 수 있는 방법을 구해서
- 그 방법중 N 사용횟수의 최솟값 return 하도록 함수를 만들어라
- N : 1 이상 9 이하
- number : 1 이상 32000 이하
- 나누기 연산에서 나머지는 무시
- 최솟값이 8보다 크면 -1 return

### 접근 방식
- 최대로 사용할 수 있는 N의 개수는 8개라는 점 이용
- 1개부터 N 개까지 사용했을 떄 만들 수 있는 수를 찾았다
- 여기서 만든 수를 사용해서 사칙연산을 처리하면 될 것 같은데, 처리 방법을 모르겠다

### 놓쳤던 부분
- set 혹은 HashSet을 사용할 수 있는 것
- 풀이를 봐도 이해와 구현이 어려워서 풀이를 여러개 정리해봐야할 것 같다...
- 조금 더 쉬운 풀이를 찾으시면 알려주세요!
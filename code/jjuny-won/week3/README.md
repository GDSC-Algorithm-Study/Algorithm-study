# 3주차 README

## 1. DFS 와 BFS (boj_1260) -> 해결

### 문제
- 정점의 개수와 , 간선의 개수 , 탐색을 시작할 정점의 번호 V가 주어진다
- 간선이 연결하는 두 정점의 번호가 주어진다
- DFS 를 수행한 결과, BFS 수행한 결과를 출력한다

### 접근 방법1 -> 실패
#### DFS
- 스택 구현을 위한 visited 리스트 만듦
- 입력받은 정점번호 에 해당하는 visited 번쨰 요소를 True로 지정
- 반복문을 통해 입력받은 수 (n) 이 있는 배열을 찾음
- n의 짝이 visited 에 True, False 인지 찾음
- False 인 경우에만 queue 에 append, visited 에 True로 표시

### BFS
- 해당하는 queue 의 v를 찾고 , 짝궁인 요소를 모두 queue에 더함
- queue에서 popLeft 함수 사용해 재귀로 반복

### 접근 방법2 -> 성공

- 행렬을 만들어서, 간선을 표시
- 방문 리스트를 만들어서, 해당 요소가 방문 했는지 요소를 체크 (다시 방문 못하기 때문)

### DFS 
- 들어온 요소 방문 visited[v] = 1 로 만듦
- 방문 요소 출력
- 반목문으로 1부터 n+1 까지 돌림(인덱스 번호가 0부터 시작해서 1~n+1로 범위 잡음)
- 앞에서 행렬에 표시한 이차원배열의 값이 1인지 -> 둘 이 연결되어있는지 확인
- 방문 한 적이 없는지 확인
- 앞의 두가지 조건을 만족하면 dfs(i) 로 재귀 함수 실행

### BFS
- queue에 탐색 노드를 넣는다
- 방문 리스트에도 1로 표시
- while 문을 활용해, queue에 비워질떄까지 반복
- v = queue에서 pop 한 요소를 담고 출력

- 앞에서 행렬에 표시한 이차원배열의 값이 1인지 -> 둘 이 연결되어있는지 확인
- 방문 한 적이 없는지 확인
- 반복문을 통해 해당 탐색 노드에서 이어진 노드들을 확인한다
- 만약에 두가지 조건을 만족하면 , queue.append(i) 하고 방문 행렬[해당요소]=1로 체크한다

#### 어려웠던 부분
- DFS, BFS 개념에 대해 헷갈려서, 이해하는데 시간이 많이 걸렸다.
- 이코테 책을 보면서  하니, 그 로직만 생각이 나서 활용, 적용이 어려웠다.
- deque 라이브러리 사용이 아직 어려워서 추가적으로 정리가 필요할 것 같다.
- 개념 부터 이해하기 어려워서, 블로그를 참고해 그림을 그려가며 이해했다.

---

## 2. 숨바꼭질 2 (boj_12961)  -> 미해결

### 문제
- 걷는다면  X-1 ,X+1 로 이동
- 순간이동하는 경우에는  2*X의 위치로 이동
- 수빈이와 동생의 위치가 주어졌을 떄, 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지, 가장 빠른 시간으로 찾는 방법이 몇 가지 인지 구하는 프로그램

- 두 가지 계산 방법 을 이용해 X 를 Y로 만드는 방법을 구하는 문제

#### 접근 방법  
- BFS 활용
- 리스트에 가능한 간선 표시
- 반복문으로 리스트 [x-1,x+1,2*x] 로 하나씩 가져오면서
- x 로 만들 수 있는지 확인하고, visited 확인

#### 어려웠던 부분
- 일단 BFS 활용까지는 나왔는데, 이걸 리트스에 표시하는 부분이 아직 어렵다
- for 문 안에 제어할 만한 if 문이 들어가야할 것 같은데, 무한루프에 걸려버렸다..
- 문제 접근까지는 가지만, 세부적인 코드 짜는게 아직 어렵다.

## 3. 거리두기 확인하기 (boj_12961)  -> 미해결(구글링)

### 문제
- 다음 규칙으로 대기실에 거리를 두고 앉도록 안내하였다
- 대기실은 5개이며, 각 대기실은 5x5 크기입니다.
- 거리두기를 위하여 응시자들 끼리는 맨해튼 거리1가 2 이하로 앉지 말아 주세요.
- 단 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용합니다.
- 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 places가 매개변수로 주어진다
- 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 

#### 접근 방법  
- BFS 활용
- 앞에서 문제와 같이 맨헤튼 거리를 반복문에 적용
- 거리두기를 하지 않은 사람이 있는지 조건문을 사용해서 체크
- 각 응시자들의 거리를 확인하며, 거리가 1인 경우 2인경우(파티셥 없는 경우) 를 확인
- 거리두기하지 않는 경우 0 return 하도록 함

#### 어려웠던 부분
- 처음에 규칙을 어떤식으로 적용해야할지 막막했었다
- BFS 활용까지는 알 수 있지만, 세부적인 구현을 하려고 하면 어려워하는 것 같다
- 1시간이 넘게 세부화가 되지 않아, 제일 이해하기 쉬운 블로그를 보며 이해하였다. 


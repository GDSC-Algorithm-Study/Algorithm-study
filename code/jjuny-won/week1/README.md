# 1주차 README
--- 
## 1.수리공 항승 (boj_1449)

### 문제
- 테이프를 이용해 물을 막으려고 한다. 
- 물을 막을 때는 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.
- 물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성

### 해결방법

#### 시도 방법1 -> 틀림
- 총 필요한 테이프의 길이는 입력받은 n 과 같았다 -> nL가 필요
- 총 필요한 테이프의 길이//테이브의 길이 = n//l 이 나머지가 생길 경우 1을 더해주는 로직을 생각했다
반례
5 3
1 2 3 4 1000
2 -> 정답은 3
#### 시도 방법2 -> 실패
- 테이프를 붙일 수 있는 범위 0.5~3.5를 구한후
- 반복문을 이용해 각 위치가 3.5보다 작으면 새로운 위치 갱신하는 로직
- 다양한 반례 진행하던 중 답이 나오지 않음 
#### 시도 방법3 -> 성공
- 거의 한시간 가까이 고민해도 답이 나오지 않아 블로그 참조
- sort()를 사용해 오름차순으로 정렬
- start를 첫번째 위치로 설정, start 부터 테이프가 커버할 수 있는 거리를 구함
- 위치를 하나씩 가져와서 start, start+l 사이에 위치할 경우, continue
- 범위를 벗어날 경우, start에 해당 location을 다시 넣고, cnt +=1 를 해서 새로운 기준으로 반복


### 부족했던 부분
- 어떤 로직과 규칙을 발견하려고 했던 부분 -> 우선 그냥 그대로 코드를 작성했으면 더 빨랐을 것 같다 
- 내가 생각했던 로직을 코드로 구현하는 것이 아직 어렵다

---
## 2. 강의실 배정(boj_11000)

### 문제
- 수업의 개수 , 수업 시작 시간, 끝나는 시간 이 주어진다
- 수업이 끝난 직후 다음 수업 시작 가능

### 해결 방법

#### 시도 방법1 -> 틀림
수업 시간은 start ~ (end-1) 이다
즉 한 강의실을 사용할 수 있는 수업은 한 수업이 end-1 < start 인 경우라고 생각했다
```
n = int(input())
arr=[]
for  i in range(n):
    arr.append(list(map(int,input().split())))

cnt =0
start = arr[0]
for i in arr[1:]:
   if((start[1]-1) <i[0]):
       continue
   else:
       cnt+=1
       
print(cnt+1)
```
- 예제를 적용했을 때는 올바른 값이 나왔으나, 반례를 찾아서 적용시 답이 잘못 나왔다

#### 시도방법2 -> 시간 초과
끝나는 시간이 시작 시간 이하 (<=) 면 한 강의실에서 수업 가능
가능한 리스트 (시간표) 를 만들어서 리스트의 개수만 구하는 방식
```
n = int(input())
arr=[]
for  i in range(n):
    arr.append(list(map(int,input().split())))

start = arr[0]

for i in arr:
    for j in arr[1:]:
        if(i[-1] <= j[0]):
            #i를 [1,8 , 9, 16] 으로 만들어서 다시 비교
            i.append(j[0])
            i.append(j[1])
            arr.remove(j)
            # print(i)
       
print(len(arr))
```
- 다중 for문 사용
- 찾아보니 input으로 여러줄을 받으면 시간 초과가 날 수 있다고 한다. 그래서 sys.stdin.readlin()을 사용해 고쳐보았다

#### 시도 방법4 -> 시간 초과
```
import sys

n = int(sys.stdin.readline())
arr=[]
for  i in range(n):
    arr.append(list(map(int,sys.stdin.readline().split())))

for i in arr:
    for j in arr[1:]:
        if(i[-1] <= j[0]):
            #i를 [1,8 , 9, 16] 으로 만들어서 다시 비교
            i.append(j[0])
            i.append(j[1])
            arr.remove(j)
            # print(i)
       
print(len(arr))
            
```
- 시간 초과를 해결할 방법을 도저히 모르겠어서 다른 사람들이 코드를 대충 훑어봤더니 heapq를 이용
- heapq를 공부하고 적용해보았다

#### 시도 방법5 -> 성공
- 처음에는 시작 시간 기준으로 했는데,힙으로 바꾸다보니 기준이 종료시간이 맞을 것 같아서 arr[0][1]을 힙에 넣었다.
- 그래서 강의 시작 시간과 room에 넣은 끝나는 시간과 비교해서 만약에 종료시간보다 강의 시간이 빠르면 -> 새로운 강의실 개설
- 강의 시간이 끝나는 시간보다 늦게 시작 -> 한 강의실 이어서 사용

---
## 3.메뉴 리뉴열 (prog_72411)

### 문제
- 단품으로 주문한 orders가 주어진다. 
- 이 중 2명 이상 주문한 단품메뉴 조합에 대해서만 메뉴 후보에 포함하기로 했다
- 메뉴 조합은 최소 2가지 이상이다.

### 해결 방법

#### 시도 방법1 -> 
- 각 요소에서 course 만큼의 조합을 구한다 [2,3,4] 일 경우 2개 조합, 3개 조합, 4개 조합
- 각 order에서 구할 수 있는 모든 조합을 구한다.
- 문제가 이해되지 않는다.2명이상이 선택한 메뉴 조합이라고 생각했는데 그러면 3가지 조합에서도 2가지 조합을 만들어낼 수 있고, 4가지 조합에서도 2가지 조합을 만들어낼 수 있는데. 코스를 짜는 기준이 뭐지?

-  일단 각 orders의 가능한 메뉴 조합을 구했다. 그리고 그게 2이상이면 출력하도록 했다.
- 손님이 주문한 'AC,'CDE'를 기준으로 각 order ( AC , CDE) 가 다른 order에 있는 횟수를 구한다고 하면 테스트3번이 옳지 않다.
- 내가 이해하지 못 하는 부분 -> 가능한 모든 조합에서 어떻게 코스를 만드는지? 2이상인 조합이 상당히 많은데(4가지에서도 2가지를 만들수 있고, 3가지에서도 2가지 조합을 만들 수 있기 때문)

정리한 블로그
https://velog.io/@jjuny0406/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EB%A9%94%EB%89%B4-%EB%A6%AC%EB%89%B4%EC%96%BC

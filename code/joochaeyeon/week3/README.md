# 3주차 README

## DFS와 BFS [백준_1260]
### 문제 풀이 방법 ⭕ and 코드 구현 🔺
### 문제 파악
- 그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.<br/><br/>
입력<br/>
첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.<br/><br/>
출력<br/>
첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.

### 문제풀이
주어진 입력에 따라 인접 행렬 graph를 초기화한다. 깊이 우선 탐색은 재귀를 활용하여 해당 정점에서 방문 가능한 모든 정점을 방문한다. 너비 우선 탐색은 큐를 활용하여 해당 정점에서 방문 가능한 모든 정점을 차례로 방문한다. 방문한 정점은 visit1 및 visit2 리스트에 해당 인덱스를 1로 표시하여 방문 여부를 기록하며 이때 간선은 양방향이기에 graph[a][b] = graph[b][a] = 1로 기록해준다.

### 문제회고
다른사람 풀이로 공부하여 코드로 구현하였다. 아직은 문제를 보고 바로 코드로 구현하는 것에 어려움이 있기에 다른 사람의 풀이를 보며 이해를 하고 코드로 구현한다.
구현된 코드를 보지않고 내 코드화하여 문제를 푸는 시간이 필요할 거 같다.

### 라이브러리
from collections import deque<br/>
-> deque는 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조다. deque는 양쪽 끝에서의 빠른 삽입/삭제를 지원하며, 리스트보다 효율적인 연산을 제공하여 스택과 큐의 특징을 모두 가지고 있다.<br/><br/>



## 숨바꼭질 2 [백준_12851]
### 문제 풀이 방법 ⭕ and 코드 구현 ⭕ 채점결과 ❌

### 문제 파악
- 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다.
- 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.
- 수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 그리고, 가장 빠른 시간으로 찾는 방법이 몇 가지 인지 구하는 프로그램을 작성하시오.<br/><br/>
입력<br/>
첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.<br/><br/>
출력<br/>
첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.<br/>
둘째 줄에는 가장 빠른 시간으로 수빈이가 동생을 찾는 방법의 수를 출력한다.

### 문제풀이
자료구조론 큐를 사용하였다. 큐를 사용하는 이유는 너비우선을 사용하는 것이 수빈이와 동생을 찾는 최단거리라고 생각했기 때문이다.<br/>
초기설정으론 최대 N과 K가 100,000이기에 MAX를 100001로 설정해주며 초기위치인 N을 큐에 추가하고 방문 여부를 체크하는 visited 리스트를 초기화한다.<br/>
큐가 빌때까지 while 반복문을 실행하고 현재 위치를 의미하는 cur이 동생의 위치인 K와 일치하면 cnt를 증가시킨다. 이는 출력 조건인 수빈이가 동생을 찾는 방법의 수를 출력하기 위함이다.
현재 위치 cur에서 이동 가능한 세 가지 경우인 cur - 1, cur + 1, cur * 2. 이동이 가능한 경우에 해당 위치를 큐에 추가하고 방문 여부를 업데이트한다.<br/>
visited[i]가 0이거나, 현재 위치 cur를 거쳐서 방문한 횟수 visited[i]가 visited[cur] + 1보다 크거나 같은 경우에만 방문을 허용함으로써 최소 이동 횟수를 업데이트한다.

### 문제회고
어떠한 자료구조나 알고리즘을 이용해서 풀어야하는지는 알지만 이를 코드로 구현하는 과정에서 어려움을 겪어 다른 사람들의 풀이를 보고 공부하여 코드를 구현하고 있다. 아직 알고리즘을 코드로 구현하는 것이 익숙치않아 그런거같다.<br/>
코드를 구현하긴했지만 채점한 결과 틀렸다고 한다. 어떤 부분에서 잘못된지 몰라 다시 생각해보는 시간이 필요할거 같다.<br/><br/>

## 거리두기 확인하기 [프로그래머스_81302]
### 문제 풀이 방법 ⭕ and 코드 구현 ⭕ 채점결과 ❌ [정확성 76.3 / 100.0]

### 문제 파악
- 대기실은 5개이며, 각 대기실은 5x5 크기
- 거리두기를 위하여 응시자들 끼리는 맨해튼 거리1가 2 이하로 앉지 말아 주세요.
- 단, 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용한다.<br/><br/>
- 응시자가 앉아있는 자리(P)를 의미
- 빈 테이블(O)을 의미
- 파티션(X)을 의미<br/><br/>
- 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 places가 매개변수
- 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성<br/><br/>
주의<br/>
- 파티션이 존재한다면 맨해튼 거리가 2여도 거리두기를 지킨 것
- 맨해튼 거리 2이고 사이에 빈 테이블이 있는 경우는 거리두기를 지키지 않은 것<br/><br/>
출력<br/>
- 정확성 테스트 : 10초
- 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면, T1, T2 사이의 맨해튼 거리는 |r1 - r2| + |c1 - c2| 입니다. <br/><br/>

### 문제풀이
P인 응시자 위치에서 수평,수직,대각선으로 다른 응시자가 맨해튼 거리 2안에 있는지 확인한다.<br/>
입력으로 주어진 places인 table을 확인하는 check함수를 이용하여 응시자의 위치인 (x,y)를 이용해서 수평, 수직, 대각선으로 다른 응시자가 맨해튼 거리 2 안에 있는지 확인하여 거리두기를 잘 지켰는지를 확인한다. 만약 거리두기를 지키지 않았을 경우 False를 반환하고, 그렇지 않으면 True를 반환한다.<br/> 
for문을 이용해서 find즉 거리두기를 잘 지키지 않았을 경우 결과를 반환하는 answer 리스트에 0을 append하고 거리두기를 잘 지켰을 경우엔 1을 append하여 반환한다.

### 문제회고
채점 결과 정확성이 정확성 76.3 / 100.0으로 틀렸다고 나온다. 코드에서 어떤 로직이 잘못된건지 아직 알지 못하여 추후에 문제를 다시 보고 코드를 다시 구현해봐야할 듯하다. 
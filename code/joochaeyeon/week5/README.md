# 5주차 README

## 이진탐색에 대하여
이진 탐색이란 정렬된 배열에서 특정 값을 찾는 알고리즘을 의미한다.

- 이진탐색은 탐색 범위를 절반씩 줄여나가기 때문에 선형탐색에 비해 빠른 속도를 보장한다. 하지만 배열이 정렬되어 있어야 한다는 조건이 필요하기 때문에 배열이 정렬되어 있지 않은 경우에는 정렬 작업이 필요한다. 따라서 이 알고리즘은 정렬된 배열에서 주어진 값의 위치를 찾거나 특정 조건을 만족하는 가장 작은/큰 값을 찾는 데에 사용된다.<br/>
이진 탐색은 반복문 또는 재귀적으로 구현될 수 있다.

- 일반적으로 이진 탐색을 이용하여 값을 찾는 방법이 for문을 이용하는 것보다 빠르다. 이진 탐색은 정렬된 배열에서 원하는 값을 찾는 알고리즘으로 중간값을 찾아 탐색 범위를 반으로 줄이면서 값을 찾아가는 것이며, for문은 배열 전체를 순회하면서 값을 찾기 때문에
배열의 크기와 상관없이 속도가 일정하게 증가한다.<br/><br/>



## 공유기 설치 [백준_2110] 
### 문제 풀이 방법 ⭕ and 코드 구현 🔺 and 채점결과 ⭕
### 문제 파악
- 도현이의 집 N개가 수직선 위에 있으며 집 여러개가 같은 좌표를 가지는 일은 없다.
- 집에 공유기 C개를 설치하는데 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려한다.
- C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성<br/><br/>
입력<br/>
- 첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다.
- 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (0 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.<br/><br/>
출력<br/>
첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력

### 문제풀이
이진 탐색을 이용해서 사용하여 상한액을 찾는 문제로 start와 end 초기값을 1과 가장 먼 공유기와 가장 가까운 공유기 사이의 거리로 설정 설정한다.<br/>
중간값인 middle을 기준으로 공유기를 설치하면서 각 공유기 사이의 거리를 계산한다.<br/>
현재 중간값 middle을 기준으로 공유기를 설치하면서 각 공유기 간의 거리가 middle보다 크거나 같을 경우 공유기를 설치하고 cnt를 증가시킨다.<br/>
cnt가 공유기 수인 C보다 크거나 같을 경우 현재 middle 값을 result에 저장하고 가능한 최대 거리를 찾기 위해 start를 증가시키며 그렇지 않을 경우 end를 감소시켜 더 작은 거리를 탐색하도록 한다.<br/><br/>

## 예산 [백준_2512]
### 문제 풀이 방법 ⭕ and 코드 구현 ⭕ and 채점결과 ⭕
### 문제 파악
- 국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것이며 총액은 미리 정해져있다.<br/>
- 1. 모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정한다.
- 2. 모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정한다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정한다. <br/><br/>

입력<br/>
- 첫째 줄에는 지방의 수를 의미하는 정수 N (N은 3 이상 10,000 이하)
- 둘째 줄에는 각 지방의 예산요청을 표현하는 N개의 정수가 빈칸을 사이에 두고 주어진다.
- 셋째 줄에는 총 예산을 나타내는 정수 M<br/><br/>
출력<br/>
배정된 예산들 중 최댓값인 정수를 출력

### 문제풀이
이진 탐색을 이용해서 사용하여 상한액을 찾는 문제 해결하고자 low와 high 초기값을 0과 NList의 최댓값으로 설정한다.<br/>
상한액 middle보다 큰 예산 요청값이 있다면 상한액까지만 고려하고자 total을 이용해서 예산 요청값 i에 대해서 total에 min(i, mid)를 더한다.<br/>
total이 총 예산 M 이하면 현재의 mid 값을 result에 저장하고 상한액을 더 큰 값으로 찾기 위해 low를 mid + 1로 조절한다. 그렇지 않으면, 상한액을 더 작은 값으로 찾기 위해 high를 mid - 1로 조절한다.<br/><br/>


## 입국심사 [프로그래머스_43238]
### 문제 풀이 방법 ⭕ and 코드 구현 ❌
### 문제 파악
- 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있다.
- 모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고자 한다.<br/><br/>

### 문제풀이
n이 심사관 수보다 작거나 같으면 모든 심사관에게 한명씩 심사받으면 되므로 각 심사관의 시간을 더한 값을 최소 시간으로 설정한다.<br/>

그렇지 않은 경우에는 이분 탐색을 사용하여 최적의 시간을 찾는데 초기 범위는 1(left)부터 가장 오래 걸리는 심사관의 시간과 n의 곱으로 설정한다.(right) <br/>

이분 탐색을 통해 현재 중간값에서 각 심사관이 처리할 수 있는 사람 수를 계산하기 위해 중간값을 각 심사관의 시간으로 나눈 몫을 모두 더한 값을 구한다.

계산한 사람 수인 totalPeople와 목표인 n을 비교하여 현재 시간에서 처리 가능한 사람 수가 목표보다 크거나 같으면 현재 시간을 answer에 저장하고 범위를 더 작은 값으로 조절한다. 그렇지 않으면 범위를 더 큰 값으로 조절하여 최적 시간인 answer을 구한다.<br/><br/>


### 전체 문제회고
문제는 이해하였지만 완벽하게 혼자 구현하는데는 어려움을 겪고 있다.
다른 사람들의 풀이를 이해하고 그 다음 구현하는 방식으로 해결하고 있다.
혼자 코드를 구현하기 위해선 풀었던 문제를 다시 풀어보는 방식으로 진행해야할 거 같다.
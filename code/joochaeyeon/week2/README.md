# 2주차 README
## 달팽이 문제 [백준_1913]
### 문제 풀이 방법 ⭕ and 코드 구현 ❌ and 채점결과 ⭕

### 문제 파악
- 홀수인 자연수 N이 주어지면, 다음과 같이 1부터 N^2까지의 자연수를 달팽이 모양으로 N×N의 표에 채울 수 있다.
- N이 주어졌을 때, 달팽이 표 모양으로 N×N의 좌표를 출력
- 또한 찾고자하는 숫자의 좌표도 함께 출력<br/><br/>
입력<br/>
첫째 줄에 홀수인 자연수 N(3 ≤ N ≤ 999)이 주어진다. 둘째 줄에는 위치를 찾고자 하는 N2 이하의 자연수가 하나 주어진다.<br/><br/>
출력<br/>
N개의 줄에 걸쳐 표를 출력한다. 각 줄에 N개의 자연수를 한 칸씩 띄어서 출력하면 되며, 자릿수를 맞출 필요가 없다. N+1번째 줄에는 입력받은 자연수의 좌표를 나타내는 두 정수를 한 칸 띄어서 출력


### 문제풀이
[내아이디어]
- 해당 blank 배열의 한가운데 1을 기준으로 크게 상->우->하->좌로 방향이 변경되면서 달팽이 모양의 좌표 blank를 만들어간다. blank의 좌표를 채워나가면서  찾기를 원하는 숫자를 만났다면 해당 좌표를 저장해뒀다가 나중에 출력하는 형식으로 진행하고자한다.<br/>

[코드문제풀이]
- 2차원 배열에 값을 할당하면서 원하는 숫자를 만났을때 따로 좌표를 저장해둔다.
- 해당 코드는 N*N값이 n부터 시작하여 -1하면서 숫자를 할당하는 방식을 채택하였다. 이렇게 하면 (0,0)에서 부터 숫자를 할당하기에 1부터 좌표값을 할당하는 것보다 더 쉽게 접근할 수 있다.

### 문제회고
백준에서 문제를 채점하는데 많은 시간이 소요된다. 어떻게하면 효율적으로 코드를 구현할 수 있는지 고민을 해봐야할듯하다. 또한 아이디어는 있었지만 그걸 코드로 구현하지 못하였고 다른 사람의 코드를 보면서 문제를 풀었다.어떻게 접근해야하는지를 해당 코드를 통해 알았으니 추후에 문제를 내코드로 다시 풀어보는 시간이 필요할듯하다. 

<br/>

## 빗물 문제 [백준_14719]
### 문제 풀이 방법 ⭕ and 코드 구현 ⭕ and 채점결과 ⭕

### 문제 파악
- 2차원 세계에 블록이 쌓여있고 거기에 빗물이 쌓인다. 빗물의 총량이 얼마인지 구해라.
<br/><br/>
입력<br/>
첫 번째 줄에는 2차원 세계의 세로 길이 H과 2차원 세계의 가로 길이 W가 주어진다. (1 ≤ H, W ≤ 500)<br/>
두 번째 줄에는 블록이 쌓인 높이를 의미하는 0이상 H이하의 정수가 2차원 세계의 맨 왼쪽 위치부터 차례대로 W개 주어진다.<br/>
블록 내부의 빈 공간이 생길 수 없으며 2차원 세계의 바닥은 항상 막혀있다고 가정하여도 좋다.
<br/><br/>
출력<br/>
2차원 세계에서는 한 칸의 용량은 1이다. 고이는 빗물의 총량을 출력, 빗물이 전혀 고이지 않을 경우 0을 출력

### 문제풀이
[ 자료구조 : Stack을 이용 ]
stack을 이용하여 현재까지 탐색한 블록의 높이 정보를 담는 용도로 현재 높이와 stack의 top을 비교함으로써 빗물이 찰 수 있는지를 확인하고 빗물이 쌓일 수 있는 경우(이전에 쌓인 높이보다 현재 들어온 높이가 높을 경우)에 stack에서 pop하여 빗물의 양을 계산하고 stack이 비어있다면 빗물이 찰 수없는 형태임으로 break하여 빠져나가도록 구현하였다.

### 문제회고
간단한 문제라고 생각했는데 코드로 구현하고보니 생각보다 복잡하게 접근하였다.
다른 사람들의 코드를 찾아보니 스택과 같은 자료구조를 사용하지 않고 간단하게 코드로 구현하였다.
복잡하게생각해서 코드로 구현하기보단 간단하게 구현할 수 있는 방법을 고민해봐야겠다. 

<br/>

## 문자열 압축 문제 [프로그래머스_60057]

### 문제 풀이 방법 ⭕ and 코드 구현 🔺  and 채점결과 ⭕
### 문제 파악
- "abcabcdede"와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 "abcabc2de"가 되지만, 3개 단위로 자른다면 "2abcdede"가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다.
- 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성
<br/><br/>
제한사항<br/>
- s의 길이는 1 이상 1,000 이하입니다.
- s는 알파벳 소문자로만 이루어져 있습니다.<br/>
두 번째 줄에는 블록이 쌓인 높이를 의미하는 0이상 H이하의 정수가 2차원 세계의 맨 왼쪽 위치부터 차례대로 W개 주어진다.<br/>
블록 내부의 빈 공간이 생길 수 없으며 2차원 세계의 바닥은 항상 막혀있다고 가정하여도 좋다.
<br/><br/>
예시<br/>
- s = "aabbaccc" result =7 -> 2a2ba3c이렇게 해서 7
- s = "ababcdcdababcdcd" result = 9 ->2ababcdcd로 갯수세면 9개여서
- s="abcabcdede" result =8 -> 2abc2cde이기에 갯수세면 8
- s ="abcabcabcabcdededededede" result = 14
- s = xababcdcdababcdcd" result = 17

### 문제풀이
for문을 통해서 문자열 길이만큼 중복문자열 갯수들을 늘려가면서 최소 문자열을 찾는다. 여기서 s길이의 절반이 넘어가면 중복되는 부분은 없기에 len(s)//2까지 문자열 길이를 늘려가면서 확인해본다. 이전문자열의 길이만큼 현재 문자열을 비교해서 같게되면 중복되는 문자열을 세는 cnt를 증가시켜 중복되는 문자열이 2번이상나올경우 중복횟수와 해당 문자열을 저장해주고 그렇지 않을경우 문자열만 출력되도록 만들었다. 
answer을 리스트로 만들어서 만들 수 있는 문자열을 다 만든후 그 중 가장 작은 문자열을 return해주었다.
# 4주차 README

## 나이순 정렬 [백준_10814]
### 문제 풀이 방법 ⭕ and 코드 구현 ⭕ and 채점결과 ⭕
### 문제 파악
- 온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성<br/><br/>
입력<br/>
첫째 줄에 온라인 저지 회원의 수 N이 주어진다. (1 ≤ N ≤ 100,000)<br/>
둘째 줄부터 N개의 줄에는 각 회원의 나이와 이름이 공백으로 구분되어 주어진다. 나이는 1보다 크거나 같으며, 200보다 작거나 같은 정수이고, 이름은 알파벳 대소문자로 이루어져 있고, 길이가 100보다 작거나 같은 문자열이다. 입력은 가입한 순서로 주어진다.<br/><br/>
출력<br/>
첫째 줄부터 총 N개의 줄에 걸쳐 온라인 저지 회원을 나이 순, 나이가 같으면 가입한 순으로 한 줄에 한 명씩 나이와 이름을 공백으로 구분해 출력

### 문제풀이
현재 입력받아야할 건 age와 name 타입이 다른 두개를 입력받아야한다. 따라서 리스트에 append할때 int타입으로 변형해서하며 나이별로 정렬하고 나이가 같은 경우 입력된 순서로 기준으로 정렬하기에 age와 name뿐만 아니라 입력받는 순서를 알기 위해 순서 또한 함꼐 저장을 한다. 따라서 리스트로 입력을 받고 age와 입력받은 순서를 기준으로 정렬하는 방법을 이용하여 코드로 구현하였다.

### 문제회고
문제에서 제한시간이 3초여서 시간복잡도는 생각하지 않고 코드로 구현하였다. 그래서 백준에서 문제를 채점하는데 많은 시간이 소요되었다. 시간복잡도를 고려하여 어떻게하면 효율적으로 코드를 구현할 수 있는지 고민을 해봐야할 듯하다.

## 좌표 압축 [백준_18870]
### 문제 풀이 방법 ⭕ and 코드 구현 ⭕ and 채점결과 ⭕
### 문제 파악
- 수직선 위에 N개의 좌표 X1, X2, ..., XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.
Xi를 좌표 압축한 결과 X'i의 값은 Xi > Xj를 만족하는 서로 다른 좌표 Xj의 개수와 같아야 한다.
X1, X2, ..., XN에 좌표 압축을 적용한 결과 X'1, X'2, ..., X'N를 출력해보자<br/><br/>
입력<br/>
첫째 줄에 N이 주어진다.<br/>
둘째 줄에는 공백 한 칸으로 구분된 X1, X2, ..., XN이 주어진다.<br/><br/>
출력<br/>
첫째 줄에 X'1, X'2, ..., X'N을 공백 한 칸으로 구분해서 출력한다.<br/><br/>
제한<br/>
- 1 ≤ N ≤ 1,000,000
- -109 ≤ Xi ≤ 109

### 문제풀이
set(num)을 통해 입력된 수열에서 중복된 값을 제거하고 정렬함으로써 좌표 압축을 시킬 수 있도록한다.<br/>
enumerate(sortNum) 코드를 통해 정렬된 값들에 대해 인덱스와 값을 동시에 반환한다. 딕셔너리 compression을 사용하여 정렬된 값들을 키로 하고 해당 값의 인덱스를 값으로 하는 딕셔너리를 생성한다.<br/><br/>

## 파일명 정렬 [프로그래머스_17686]
### 문제 풀이 방법 ⭕ and 코드 구현 ⭕ and 채점결과 ⭕
### 문제 파악
- 소스 파일 저장소에 저장된 파일명은 100 글자 이내로, 영문 대소문자, 숫자, 공백(" "), 마침표("."), 빼기 부호("-")만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다.
- 파일명은 크게 HEAD, NUMBER, TAIL의 세 부분으로 구성
HEAD는 숫자가 아닌 문자로 이루어져 있으며, 최소한 한 글자 이상이다.<br/>
NUMBER는 한 글자에서 최대 다섯 글자 사이의 연속된 숫자로 이루어져 있으며, 앞쪽에 0이 올 수 있다. 0부터 99999 사이의 숫자로, 00000이나 0101 등도 가능하다.<br/>
TAIL은 그 나머지 부분으로, 여기에는 숫자가 다시 나타날 수도 있으며, 아무 글자도 없을 수 있다.
입력<br/>
입력으로 배열 files가 주어진다.<br/>
files는 1000 개 이하의 파일명을 포함하는 문자열 배열이다.
각 파일명은 100 글자 이하 길이로, 영문 대소문자, 숫자, 공백(" "), 마침표("."), 빼기 부호("-")만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다.
중복된 파일명은 없으나, 대소문자나 숫자 앞부분의 0 차이가 있는 경우는 함께 주어질 수 있다. (muzi1.txt, MUZI1.txt, muzi001.txt, muzi1.TXT는 함께 입력으로 주어질 수 있다.)<br/><br/>
입출력 예제<br/>
1. 입력: ["img12.png", "img10.png", "img02.png", "img1.png", "IMG01.GIF", "img2.JPG"]
출력: ["img1.png", "IMG01.GIF", "img02.png", "img2.JPG", "img10.png", "img12.png"]<br/>
2. 입력: ["F-5 Freedom Fighter", "B-50 Superfortress", "A-10 Thunderbolt II", "F-14 Tomcat"]
출력: ["A-10 Thunderbolt II", "B-50 Superfortress", "F-5 Freedom Fighter", "F-14 Tomcat"]

### 문제풀이
정규 표현식 \D+은 숫자가 아닌 모든 문자에 매칭한다. 대소문자를 구분하지 않고 정렬하기 위하여 x.lower()를 통해 파일명을 소문자로 변환한다.<br/>
정규 표현식 \d+는 숫자에 매칭한다. 람다 함수는 주어진 파일명 x를 받아 튜플로 변환하여 튜플의 첫 번째 요소는 문자열 부분이며, 두 번째 요소는 숫자 부분을 이용한다.<br/>
sorted 함수를 사용하여 파일명들을 주어진 키 함수에 따라 정렬하는데 정렬 기준은 람다 함수를 통해 정의한 튜플이다. 먼저 문자열 부분을 기준으로 정렬하고, 그 다음에 숫자 부분을 기준으로 정렬한다.<br/>

### 라이브러리
- re 라이브러리 사용
re라이브러리는 정규 표현식을 처리하는 라이브러리로 문자열 매턴 매칭, 검색, 치환과 같은 작업을 수행

사용예시
- re.match(pattern, string, flags=0)<br/>
문자열인 string의 시작 부분에서 정규표현식 패턴과 일치하는지 확인한다.

- re.search(pattern, string, flags=0)<br/>
주어진 string이 정규 표현식 패턴과 일치하는 첫번째 부분을 찾는다.

- re.fullmatch(pattern, string, flags=0)<br/>
문자열 전체가 정규 표현식 패턴과 완전히 일치하는지 확인

- re.finditer(pattern, string, flags=0)<br/>
문자열에서 정규 표현식 패턴과 일치하는 모든 부분을 반복 가능한 객체로 반환

- re.sub(pattern, repl, string, count=0, flags=0)<br/>
문자열에서 정규 표현식 패턴과 일치하는 부분을 대체 문자열로 교체

- re.split(pattern, string, maxsplit=0, flags=0)<br/>
문자열을 정규 표현식 패턴을 기준으로 분할하고 리스트로 반환

# 8주차 README

## 도시 분할 계획 [백준_1647] 
### 문제 풀이 방법 ⭕ and 코드 구현 🔺 채점결과 ⭕
### 문제 파악
- 마을은 N개의 집과 그 집들을 연결하는 M개의 길, 길은 어느 방향으로든지 다닐 수 있다.<br/> 그리고 각 길마다 길을 유지하는데 드는 유지비가 있으며 임의의 두 집 사이에 경로가 항상 존재한다.
- 마을의 이장은 마을을 두 개의 분리된 마을로 분할할 계획을 가지고 있다. 
- 마을을 분할할 때는 각 분리된 마을 안에 집들이 서로 연결되도록 분할해야 한다. 각 분리된 마을 안에 있는 임의의 두 집 사이에 경로가 항상 존재해야 한다는 뜻
- 마을을 분할할 때는 각 분리된 마을 안에 집들이 서로 연결되도록 분할해야 한다. 각 분리된 마을 안에 있는 임의의 두 집 사이에 경로가 항상 존재해야 한다는 뜻
#### [계획 변동]
- 일단 분리된 두 마을 사이에 있는 길들은 필요가 없으므로 없앨 수 있다. 
- 각 분리된 마을 안에서도 임의의 두 집 사이에 경로가 항상 존재하게 하면서 길을 더 없앨 수 있다.<br/> 마을의 이장은 위 조건을 만족하도록 길들을 모두 없애고 나머지 길의 유지비의 합을 최소로 하고자 한다.<br/><br/>
### 입력
- 첫째 줄에 집의 개수 N, 길의 개수 M
- M줄에 걸쳐 길의 정보가 A B C 세 개의 정수로 주어지는데 A번 집과 B번 집을 연결하는 길의 유지비가 C (1 ≤ C ≤ 1,000)라는 뜻<br/><br/>

### 출력
첫째 줄에 없애고 남은 길 유지비의 합의 최솟값을 출력<br/><br/>

### 문제풀이
이 코드는 크루스칼 알고리즘을 사용하여 주어진 그래프에서 최소 신장 트리를 찾는 문제를 해결하였다.<br/> parent 리스트를 통해 각 노드의 부모 노드를 관리하고 edges 리스트를 가중치 순으로 정렬한 뒤 반복문을 통해 간선을 선택하게 된다. 만약 선택된 간선의 양 끝 노드가 같은 집합 즉 부모가 같지 않다면 해당 간선을 선택하고 두 집합을 합친다. 이때 선택된 간선의 가중치를 total_cost에 더해주고 최대 가중치를 갱신하게 한다. 모든 간선을 탐색한 뒤 total_cost에서 최대 가중치를 뺀 값을 결과로 출력하는데 이 값은 최소 신장 트리에서 제외된 간선의 가중치를 의미한다.


## 장난감 조립 [백준_2637] 
### 문제 풀이 방법 ⭕ and 코드 구현 🔺 채점결과 ⭕
### 문제 파악
- 장난감을 만드는데는 기본 부품과 그 기본 부품으로 조립하여 만든 중간 부품이 사용된다. <br/> 기본 부품은 다른 부품을 사용하여 조립될 수 없는 부품이다. 중간 부품은 또 다른 중간 부품이나 기본 부품을 이용하여 만들어지는 부품이다.<br/><br/>
#### 입력
- 첫째 줄에는 자연수 N(3 ≤ N ≤ 100), N은 완제품의 번호를 나타낸다.
- 두번째 줄에는 자연수 M(3 ≤ M ≤ 100),
- 세번째 줄부터는 M개의 줄에는 어떤 부품을 완성하는데 필요한 부품들 간의 관계가 3개의 자연수 X, Y, K로 주어진다. 이 뜻은 "중간 부품이나 완제품 X를 만드는데 중간 부품 혹은 기본 부품 Y가 K개 필요하다"는 뜻이다. 두 중간 부품이 서로를 필요로 하는 경우가 없다.<br/><br/>

#### 출력
- 하나의 완제품을 조립하는데 필요한 기본 부품의 수를 한 줄에 하나씩 출력하되(중간 부품은 출력하지 않음), 반드시 기본 부품의 번호가 작은 것부터 큰 순서가 되도록 한다. 
- 각 줄에는 기본 부품의 번호와 소요 개수를 출력<br/><br/>

### 문제풀이
문제에서는 여러 부품들 간의 종속 관계와 각 부품의 개수가 주어지고 최종 제품을 만들기 위해 필요한 각 부품의 최소 개수를 출력하여야하기에 위상 정렬을 활용하여 문제를 해결하였다.<br/>
Topological Sort 함수에서 graph는 부품 간의 종속 관계와 개수를 나타내는 그래프, in_degree는 각 부품의 진입 차수, basic_components는 각 부품의 기본 개수로 자기 자신이 기본 부품이 아니면 0이 된다. 이 함수는 위상 정렬을 수행하여 각 부품의 최소 개수를 계산하여 반환하게 되고 큐를 사용하여 진입 차수가 0인 기본 부품을 차례로 처리하면서 최종 결과를 계산하게 된다.

## 최단경로 [프로그래머스_257811] 
### 문제 풀이 방법 ⭕ and 코드 구현 ⭕ 채점결과 ⭕
### 문제 파악
- 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프들이 있다. 이 그래프들은 1개 이상의 정점과, 정점들을 연결하는 단방향 간선으로 이루어져 있다.
#### 도넛 모양 그래프
- 크기가 n인 도넛 모양 그래프는 n개의 정점과 n개의 간선이 있다.
- 도넛 모양 그래프의 아무 한 정점에서 출발해 이용한 적 없는 간선을 계속 따라가면 나머지 n-1개의 정점들을 한 번씩 방문한 뒤 원래 출발했던 정점으로 돌아오게 된다.
#### 막대 모양 그래프
- 크기가 n인 막대 모양 그래프는 n개의 정점과 n-1개의 간선이 있다.
- 막대 모양 그래프는 임의의 한 정점에서 출발해 간선을 계속 따라가면 나머지 n-1개의 정점을 한 번씩 방문하게 되는 정점이 단 하나 존재한다.
#### 도넛 모양 그래프
- 크기가 n인 8자 모양 그래프는 2n+1개의 정점과 2n+2개의 간선이 있다.
- 8자 모양 그래프는 크기가 동일한 2개의 도넛 모양 그래프에서 정점을 하나씩 골라 결합시킨 형태의 그래프다.
#### 구해야하는 부분
도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프가 여러 개 있다. 이 그래프들과 무관한 정점을 하나 생성한 뒤, 각 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프의 임의의 정점 하나로 향하는 간선들을 연결했다. 그 후 각 정점에 서로 다른 번호를 매겼다.이때 당신은 그래프의 간선 정보가 주어지면 생성한 정점의 번호와 정점을 생성하기 전 도넛 모양 그래프의 수, 막대 모양 그래프의 수, 8자 모양 그래프의 수를 구해야 한다. <br/><br/>

### 문제풀이
saveGraph 함수는 주어진 간선 정보를 이용하여 그래프를 생성한다. graph defaultdict를 사용하여 각 노드와 그 노드에 연결된 노드들의 리스트를 저장하며 indegree defaultdict를 사용하여 각 노드의 진입 차수를 저장한다.<br/>
진입 차수가 0이고 연결된 노드가 2개 이상인 노드 찾기 : findZeroIndegreeNode 함수
findZeroIndegreeNode 함수는 indegree가 0이면서 그 노드와 연결된 노드가 2개 이상인 노드를 찾아 반환한다.<br/>
dfs 함수는 주어진 노드에서 DFS를 수행하여 부분 그래프의 정보를 찾는다. isEightGraph 변수는 현재 부분 그래프가 특정 조건을 만족하는 경우를 나타내고 isBarGraph 변수는 다른 조건을 만족하는 경우를 나타낸다.
내가 작성한 코드는 주어진 노드에서 dfs 함수를 호출하여 부분 그래프의 정보를 찾고, 해당 정보를 이용하여 각각의 부분 그래프 개수를 카운트하게 되어 최종적으로 [createdNodeNumber, numberOfDonutGraph, numberOfBarGraph, numberOfEightGraph] 형태로 결과를 반환하게 된다.
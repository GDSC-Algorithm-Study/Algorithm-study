# 수리공 항승(BOJ 1499)
테이프가 제 기능을 하기 위해 최소 좌우 0.5의 간격이 필요합니다.</br>
테이프를 최소로 쓰기 위해서는 하나의 테이프로 가장 많은 누수를 막아야 하는, 낭비되는 공간이 가장 적어야 합니다. </br>
편의상 주어진 위치들을 x축 위의 좌표라고 생각하겠습니다.</br>
가장 처음 나타나는, 즉 가장 작은 좌표의 왼쪽에는 더이상 누수가 없습니다. 즉 가장 작은 좌표를 n 이라고 했을 때 (n - 0.5) 보다 작은 위치에 존재하는 테이프는 효용이 없습니다.</br>
고로 첫 테이프의 위치는 (n - 0.5)가 되어야 할 것입니다.</br>

임의의 좌표 k 에 길이가 l 인 테이프를 붙인다고 해보겠습니다.</br>
테이프를 왼쪽부터 붙인다고 가정했을 때 k 의 누수를 막으려 테이프를 붙인다면 테이프가 도달하는 좌표는 (k + l - 0.5) 가 될 것입니다.</br>
테이프의 길이가 자연수이므로 k 부터 ⌊(k + l - 0.5)⌋ = (k + l -1) (∵ k, l ∈ N) 까지의 구간은 모두 테이프가 붙어있습니다.</br>
고로 k에 테이프를 붙였다면 (k + l) 부터의 좌표부터 다시 누수를 고려하면 된다는 것입니다.</br>

(n - 0.5)에 테이프를 붙였기 때문에 (n + l) 이상의 좌표가 다음 누수가 생기는 가장 작은 좌표이고 처음에 한 얘기를 그 좌표에 다시 적용시키면 이 문제를 해결할 수 있습니다.</br>

x축을 왼쪽부터 순회하기 위해 우선 주어진 좌표들을 오름차순으로 정렬합니다.</br>
테이프의 개수를 저장할 변수와 테이프의 끝 점을 저장할 변수를 선언합니다.</br>
만약 누수가 있는 좌표가 테이프의 끝점보다 크다면 테이프의 개수를 1 추가하고 끝점을 갱신합니다.</br>

정렬하는데 O(n log n) 순회하는데 O(n) 으로 총 O(n log n)의 복잡도를 가질 것입니다.

# 강의실 배정(BOJ 11000)
결국 모든 강의가 진행되어야 하므로 처음부터 끝까지 강의가 진행되면서 사용중인 강의실이 가장 많을 때를 찾는 것과 같습니다.</br>
강의가 시작되면 사용중인 강의실이 1개 늘 것이고, 강의가 종료되면 1개 줄어들 것입니다.</br>

시작시간 s 와 종료시간 t 가 주어진다면 이것을 분리하여 [s, 1], [t, -1] 로 저장합니다. 이는 s 일 때는 사용중인 강의실이 1개 늘 것이고 t 일 때 1개 줄 것이라는 것을 의미합니다.</br>
모든 입력을 이런식으로 처리하고 난 후 첫 원소인 시간 순으로, 시간이 같다면 종료하는 것이 먼저 오도록 오름차순 정렬합니다.</br>
그후 배열을 순회하며 두 번째 원소들을 더해갑니다. 이것이 현재 사용중인 강의실의 수를 의미합니다.</br>
만약 강의가 끝날 때 그것이 어떤 강의인지는 궁금하지 않습니다. 시작하지 않은 강의가 끝날 일은 없기 때문입니다.</br>
그렇게 더해가는 과정에서 나오는 최대치가 이 문제의 답이 되겠습니다.</br>

입력을 분할하는데 O(n) 정렬하는데 O(n log n) 이후 순회하는데 O(n) 으로 이것도 O(n log n)의 복잡도를 가질 것 입니다.

# 메뉴 리뉴얼(PROG 72411)
처음 고안한 방법은 알파벳 26개에 각각 고유한 소수를 부여하고 그것의 곱으로 문자열을 고유의 숫자로 나타내려 했습니다.</br>
A가 2, B가 3이되고 Z가 101이 되며 ABZ라는 문자열은 2 * 3 * 101 = 606이 되는 식입니다.</br>
그 후 orders에 2번 이상 등장한 문자들만을 고려하여 course에 들어있는 숫자만큼 조합을 뽑고, 그 조합 또한 숫자로 변환하여 orders의 문자들을 나누어 나머지가 0이면 숫자를 세어 가장 많이 등장한 조합들을 선택하려 했습니다.</br>
예를 들면 AC = 2 * 5 = 10 이고, AZ = 2 * 101 = 202 일 때 ABZ = 606이 AC로는 나누어 떨어지지 않고 AZ로는 나누어 떨어지니 AC는 포함하지 않고 AZ는 포함하겠구나 하는 식입니다.</br>

문제는 조합을 뽑는 방식이였는데, 2번 이상 나온 문자로 무작정 조합을 뽑으면 경우의 수가 너무 많이 나왔습니다.</br>
최악의 경우가 알파벳 26개 모두 2번 이상 등장한 경우에 10개를 고르는 것인데 이 경우 5311735 개의 경우가 나오며, 심지어 조합을 구현한 함수가 재귀함수였습니다.</br>
이 부분을 수정해야 했는데, 2번 이상 등장한 문자에서 조합을 뽑아도 orders에서 등장할 수 없는 조합이 생김을 발견했습니다.</br>
예를들면 AB, ABC, CD, DE 에서 A와 D 모두 2번 이상 등장했으나 AD를 포함하는 문자열이 없는 경우입니다.</br>

그래서 조합을 뽑는 집합을 2번 이상 등장한 문자가 아닌 다른 방식으로 바꾸었습니다.</br>
course의 원소 중 하나가 n 이라 할 때 길이가 n 이상인 문자열만 orders에서 선별하고, 그 문자열별로 크기가 n인 조합을 뽑았습니다.</br>
이러면 최악의 경우의 수가 길이가 10인 문자열 20개에서 크기가 5인 조합들을 뽑아내는 경우인데 10 C 5 * 20 = 5040으로 거의 1000배 가까이 경우의 수가 줄어들었습니다.</br>

그러다 굳이 숫자로 변환을 해야할까 라는 생각에 봉착했습니다.</br>
왜냐하면 바꾼 방식에서는 조합 중 겹치는 원소들이 생깁니다. 예를들어 ABC와 BCD에서 크기가 2인 조합을 뽑을 때 BC가 겹치는 식입니다.</br>
배열에서 중복을 제거하고 나눗셈을 진행해야 하는데 이 과정이 번거로웠습니다.</br>
그래서 그냥 각 course별 나온 조합들을 모조리 세면서 최대빈도수가 2 이상일 경우 최빈값들을 answer에 넣어주기로 했습니다.</br>

시간복잡도는 조금 별로입니다. 조합을 구함에 있어 재귀함수를 선택했기 때문에 지수형태의 복잡도를 가질 것 같습니다. 계산을 하는데 자꾸 헷갈려서 정확한 값은 추후에 더 생각해보겠습니다. 그리고 더 나은 방법도 찾아보아야겠지요.



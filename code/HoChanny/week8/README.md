## 도시 분할 계획(BOJ_1647)
최소 신장 트리를 만들고 가장 비용이 큰 간선을 하나 지우면 되는 문제였습니다.

정점이 n 개 일 때 최소 신장 트리는 n - 1개의 간선을 가지니 원하는 조건에서는 n - 2개의 간선을 가질 것 입니다.

간선을 비용 순으로 정렬하고 크루스칼 알고리즘을 사용하면 마지막에 지울 간선을 고려할 필요 없이 선택한 간선이 n - 2개가 될 때 까지만 반복하면 됩니다.

## 장난감 조립(BOJ_2637)
입력에서 3번째 줄 부터 [x, y, k]가 주어집니다. 이를 정점 y에서 x로 향하는 간선이라고 생각하고 그래프를 그립니다. in-degree가 0인 정점들이 기본 부품이 될 것입니다.

필요한 부품의 개수를 세는데 (n + 1) * (n + 1) 테이블을 사용했습니다. dp[i][j] 는 i를 만드는데 필요한 j의 개수입니다. 단, 기본 부품만 개수를 셀 것이며 중간 부품은 그것을 이루는 기본 부품의 구성으로 치환될 것입니다. 다시 말해 dp[i][j]가 0보다 큰 수라면 j는 기본 부품이라는 이야기입니다.

n이 기본 부품이라고 하면 dp[n][n] = 1을 대입해줍니다. 그 후에 위상정렬을 수행하며 작은 단위의 중간 부품부터 차례대로 기본 부품의 구성으로 치환해줍니다. [x, y, k] 에서 dp[y] 의 각 원소마다 k만큼 곱해서 인덱스에 맞게 dp[x]에 더해줍니다.

다 진행이 된 후 dp[n]을 순회하며 값이 0보다 큰 원소들과 개수를 출력하면 되겠습니다.

## 도넛과 막대 그래프(PROG_258711)
edges의 원소 [x, y]가 있으면 x의 out-degree와 y의 in-degree가 1 증가합니다. edges를 순회하며 각 번호별로 in/out-degree를 계산해줍니다.

편의상 in/out-degree를 in/out만 표기하겠습니다. 그림을 좀 그려보니 각 정점의 in과 out을 살펴보면 특정할 수 있는 몇가지 조건들이 있었습니다.

1. in = 0 && out >= 2 이면 이 정점이 생성된 정점입니다. 생성된 정점에 연결된 그래프의 수가 2개 이상이고, 이 정점은 out만 가지기 때문입니다. 다른 정점 중에 in이 0인 경우는 막대 모양 그래프의 시작점인데, 이 경우에는 out이 1이므로 위 조건을 만족하는 정점은 생성된 정점 단 하나입니다. 그래고 생성된 정점의 out 값이 연결된 그래프의 총 개수입니다.

2. out = 0 인 정점은 막대 모양 그래프의 끝점 뿐입니다.

3. out이 2고 in이 2 혹은 3인 점은 8자 모양 그래프를 구성하는 두 도넛 모양 그래프의 결합부분입니다. 원래 in/out이 2/2인데 생성 정점에서 이 부분이 연결되면 in이 3이 됩니다.

도넛 모양은 특정할 수 있는 점이 없습니다. 여기서 나타나는 in/out은 8자 모양에서 똑같이 나오기 때문입니다. 하지만 전체 개수를 알고 있으니 다른 2가지 그래프의 개수를 구한 후 나머지가 도넛 모양의 개수가 될 것입니다.

그림을 그려보면 대부분의 점이 in/out이 1/1이여서 규칙이 눈에 잘 띄었던 것 같습니다.

번호가 1000000 까지여서 in/out을 100만 크기의 배열에 다 0으로 초기화 했는데 바람직하진 않은 것 같습니다. 번호가 몇 개 없을 때 시간이든 공간이든 낭비가 너무 심한데 Object나 Map으로 나온 번호만 처리하면 좀 나아질 것 같습니다. 추후에 수정 해 보도록 하겠습니다.
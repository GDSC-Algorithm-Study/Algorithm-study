## 평범한 배낭(BOJ_12865)
k + 1 크기의 1차원 배열을 사용합니다. 각 인덱스는 인덱스 만큼의 무게가 한계일 때 가장 높은 가치를 담습니다.

각 물품에 대하여 (무게가 w, 가치가 v) 배열의 k + 1번 부터 0번까지 다음을 비교합니다. 현재 인덱스를 i라고 하겠습니다.

max(dp[i], dp[i - w] + v)

이는 지금 선택된 물건을 담지 않을 경우와 담을 경우를 비교하여 높은 가치를 고릅니다.
배열을 뒤에서부터 탐색하는 이유는 앞에서부터 탐색하게 되면 같은 물품이 2번 이상 선택되는 경우가 생기기 때문입니다.

## 합분해(BOJ_2225)
우선 조건에 대해 생각해 보겠습니다. k개의 숫자를 나열하며 덧셈을 할 것인데, 마지막 숫자에만 관심이 있습니다. 마지막 숫자는 0부터 N까지의 정수가 올 수 있습니다. 0을 택했다면 그 앞의 식이 k - 1개의 숫자로 N을 만들어야 할 것이고, 1을 택하면 k - 1개의 숫자로 N - 1을 만들어야 할 것입니다.

이번엔 2차원 배열을 사용합니다. dp[i][j] 는 i개의 숫자로 j를 만드는 가짓수 입니다. 궁극적인 목표는 dp[k][n]을 구하는 것이 되겠지요.

i개의 숫자로 j를 만들려면 위에 언급했듯 i - 1개의 숫자로 j 부터 0 까지의 숫자를 만들어 남는 만큼 더해주면 되겠지요. 이를 점화식으로 작성하면 다음과 같아집니다.
```
dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + ... + dp[i - 1][1] + dp[i - 1][0]

          //순서대로 마지막 더하는 수가 0, 1, ... , j 인 경우의 수
```
여기서 식을 조금 더 간단하게 가져갈 수 있습니다. 우선 마지막에 0을 더하는 경우는 dp[i - 1][j]입니다. 이제 1부터 j - 1까지의 경우를 찾아야 합니다. 이는 dp[i][j - 1]과 같은데, 그 이유는 다음과 같습니다.

dp[i][j - 1] 은 i - 1개의 숫자의 합에 0부터 j - 1까지 더해 j - 1이 되는 경우가 담겨있습니다. 여기서 더하는 수에 각각 1을 더해보면 i - 1개의 숫자의 합에 1부터 j까지 더해 합이 j가 되는 경우로 바뀝니다. 고로 점화식을 다음과 같이 간추릴 수 있습니다.
```
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
```
테이블을 채워가려면 숫자가 몇개 주어져야겠지요. 임의의 정수 x에 대해 dp[x][0], 즉 x개의 숫자로 0을 만드는 법은 0을 x개 더하는 경우 한가지 입니다. 그리고 dp[1][x], 즉 1개의 숫자로 x를 만드는 법은 x를 한번 더하는 경우 한가지입니다. 저는 따로 처리하기 귀찮아서 그냥 배열을 만들 때 전부 1로 채웠습니다.

# N으로 표현(PROG_42895)
배열의 k번 행에는 k번만큼 숫자를 사용했을 때 얻을 수 있는 값들을 담습니다. 최솟값이 8이 넘어가면 -1을 출력하면 되니 배열이 8번 행까지 갖게 설정하고, 중복을 방지하기 위해 각 원소에는 Set을 사용했습니다.

각 행에는 어떤 값들이 들어갈지 생각해 보겠습니다. 예를들어 5번 행이라면 다음과 같은 경우가 생깁니다. 우선 사칙연산을 행하는 경우부터 보겠습니다.

 |앞부분|뒷부분|
|------|---|
|N이 1번인 경우|N이 4번인 경우|
|N이 2번인 경우|N이 3번인 경우|
|N이 3번인 경우|N이 2번인 경우|
|N이 4번인 경우|N이 1번인 경우|

앞부분과 뒷부분 사이에 연산자를 넣은 값이 사칙연산으로 얻을 수 있는 값들입니다. 여기에 NNNNN(N을 5번 나열한 N자리 수)가 전체 경우겠지요. 8번 행까지 채워보고 원하는 수가 안나오면 -1을 리턴해줍시다.
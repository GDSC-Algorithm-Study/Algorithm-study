## DFS와 BFS(BOJ_1260)
실제로 dfs와 bfs를 구현해볼 수 있는 시간이였습니다.

console.log를 사용하면 자동으로 개행이 되는데 process.stdout.write 은 개행 없이 한줄로 쭉 출력할 수 있습니다. 변수에 경로를 저장한 후 출력하지 않고 방문 즉시 출력을 할 수 있게 되는 방법을 알게 되었습니다.

## 숨바꼭질2(BOJ_12851)
주어진 조건을 n번 노드가 (n + 1), (n - 1), (n * 2)번 노드와 연결되어 있는 방향그래프라고 생각했습니다.

시작 노드와 목적지가 주어지고 최단경로의 길이와 그 개수를 파악하면 됩니다. 1초에 1의 길이만큼 이동할 수 있으므로 경로의 길이가 곧 시간이 될 것입니다.

최단경로를 찾기 위해 bfs를 이용했습니다. 방문한 노드를 처리할 때 경로의 길이도 같이 처리해줍니다. 저는 visited 배열에 -1이면 방문하지 않음, 그 외의 숫자는 그 인덱스의 노드까지 도달할 수 있는 최단경로를 적었습니다. 시작점은 0이 될 것입니다. 갱신시에는 이전 노드의 visited에 1을 더해주면 되겠습니다.

최단경로의 개수가 마지막 고려사항입니다. 저는 answer라는 배열에 각 노드까지 도달할 수 있는 최단경로의 개수를 담았습니다. 한 노드의 최초 방문시에는 최단경로를 갱신해주고, 직전 노드의 최단경로 개수를 그대로 담아줍니다. 그 후에 이 노드를 방문하게 될 시 그 경로가 최단경로인지 판별하고 맞다면 개수를 늘려주는 식으로 진행했습니다.

이런 식으로 범위 내의 모든 노드를 탐색하였습니다. 

## 거리두기 확인하기(PROG_81302)
거리두기를 지키지 못하는 경우는 다음 2가지 입니다.

1. P의 사방 중 어느 한 곳에라도 P가 존재할 경우
2. O의 사방 중 2곳 이상 P가 존재할 경우

먼저 문자열을 문자의 배열로 분할하고, 각 대기실의 25개 원소를 모두 순회하며 P나 O일 때 위 조건을 검사했습니다.

dfs, bfs를 사용하지 못한 것 같아 다른 방법도 고려해보겠습니다.


이런 문제는 냅색 알고리즘으로 풀 수 있다고 한다.

### 냅색 알고리즘

한 배낭에 담을 수 있는 무게의 최댓값이 정해져있고, 일정 가치와 무게가 있는 짐들을 배낭에 넣을 때, 가치의 합이 최대가 되도록 짐을 고르는 방법을 찾는 문제

**냅색 알고리즘을 나누는 기준**

`담을 수 있는 물건이 나뉠 수 있는가, 없는가?`

- 담을 수 있는 물건이 나누어질 때
  - 분할 가능한 배낭 문제(Fractional Knapsack Problem)
- 담을 수 있는 물건이 나누어질 수 없을 때
  - 0-1 배낭 문제(0-1 Knapsack Problem)

냅색 알고리즘의 핵심은 `특정 물건을 담지 않았을 때가 오히려 최선의 선택일 수 있음을 고려`

DP를 이용한 냅색 알고리즘 풀이

가방에 최대 Nkg까지 담을 수 있을 때, dp[i][j]는 다음과 같다.

dp[i][j] → j개의 무게를 가방에 담을 수 있을 때, i개의 물건 중 담을 수 있는 최대 가치

1. j (현재 가방에 담을 수 있는 무게)가 현재 물건의 무게 w보다 작을 때

   1. 현재 물건을 담을 수 없으므로, 이전 물건에서의 i에 해당하던 값 (i - 1)을 넣어준다.

   $$
   dp[i][j] = dp[i-1][j]
   $$

2. j가 현재 물건의 무게 w와 같거나 클 때

   1. 현재 물건을 담을 수 있음
   2. 물건을 담았을 때와 담지 않았을 때의 가치를 비교해준 뒤, 더 큰 값을 할당해줌
   3. 현재 물건의 가치는 v

   $$
   dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)
   $$

물건의 최대 가치는 dp[가방 크기][물건의 개수]로 구할 수 있다.

위 냅색 알고리즘을 이용하여 현재 문제를 풀어보았다.

```python
for i in range(1, n+1):
    for j in range(1, k+1):
        weight = bag[i][0]
        value = bag[i][1]

        if j < weight:
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight] + value)


print(dp[n][k])
```

## 참고

[[Python] 냅색 알고리즘(Knapsack Problem) - Dynamic Programming(DP)](https://inni-iii.tistory.com/74)

### 달팽이(1913)

문제
- 홀수 N이 주어지면 N * N 달팽이 모양으로 자연수를 배치
- N이 주어졌을 때, 표를 출력 N^2 이하의 자연수가 주어졌을 때는 좌표도 출력
- 입력
    - 첫째 줄에 홀수인 자연수 N(3 ≤ N ≤ 999), 둘째 줄에는 N^2 이하의 자연수

문제 접근
- 딕셔너리 사용해 볼 예정
- (1,1) 좌표의 값을 N^2으로 설정
- (i,j)로 설정하여 i= 1~N까지는 N^2 - 1 i == N이면 j = 1~N까지 계속 -1의 값을 저장
- (N,N)이 되면 N의 값을 하나 줄여서 N-1~1이 될때까지 위의 과정 실행
- 그 다음 N의 값 하나 줄이고 1~N-2까지 실행하며 좌표값이 (N-2,N-2)이면 종료

문제 풀이
- 방향값을 배열로 선언하고 1,1을 좌표 초기값으로 설정
- N*N번 만큼 반복문을 돌면서 (1,1 -> N,1 -> N,N -> 1,N -> 2,N ..) 딕셔너리에 키 값을 저장
- key는 (i,j), value는 N을 갖는 딕셔너리가 생성됨
- 이 딕셔너리를 어떻게 출력할까가 문제였다...그러다가 생각한 것은 0으로 이루어진 배열 생성
- 이 배열 값의 i,j에 dict.get(i+1,j+1) 값을 넣어주는 것이다. x,y를 1,1로 초기화 했기에 1씩 더함
- 그리고 배열 값을 출력형식과 맞게 출력하기 위해 이중 반복문과 조건문을 사용해서 출력
- 입력받은 숫자의 좌표값을 출력해주는 코드도 추가
- print문으로 풀었는데 return문으로 바꿔볼 예정
- return문으로 바꾸고 나니 실행 시간이 조금 감소했다
- 함수를 만들어서 수정했고 코드 상의 불필요한 부분을 조금 제거했음

### 빗물(14719)

문제
- 2차원 블록에 고이는 빗물의 총량
- 입력
    - H, W (높이와 너비 1<=h,w<=500)
    - 두 번째 줄 0<= Num <=H 이하의 정수 블록 높이

문제 접근
- 0으로 초기화된 이차원 배열에 블록이 있는 곳만 1로 변경해서 문제를 풀어보자
- 배열이 [1,0,1] 이런 형태이면 물이 고이고 [0,1,1] 이런 형태이면 물이 안고인다
- 이제 양쪽에서 좁혀 들어오면서 count를 체크하는 코드를 추가하자

### 문자열 압축

문제
- aabbaccc -> 2a2ba3c -> 7 이 방법을 개선
- ababcdcdababcdcd -> 2ab2cd2ab2cd -> 2개 단위로 잘라서 압축
- 8개 단위로 압축하면 2ababcdcd가 되서 최소가 됨
- 문자열 s를 최소로 압축하는 경우를 구해라

제한사항
- s의 길이는 1 이상 1,000 이하입니다.
- s는 알파벳 소문자로만 이루어져 있습니다.

문제접근
- 맨 앞부터 자를 수 있어야 함
- N/2보다 작은 수로 분할해야한다
- N/2보다 작은 수로 문자열을 분할한 뒤 앞의 분할 값과 현재 분할값이 같은지 비교
- 값을 임시 저장할 변수를 선언한다. 일치 갯수를 저장할 변수를 선언한다
- 일치하는 갯수를 count하고 이전 값과 현재 값이 다르면 count를 다시 1로 초기화 하면서 이중 반복문을 실행

문제회고
- 배열을 비교하고 변환해서 [a,a,b,b,c,c,c]로 저장해보거나 counter를 사용하려 해보기도 했음
- 하다보니 코드가 너무 더러워지고 길어져서 원점으로 돌아갔음
- counter 함수처럼 2a2b3c로 만들어 보자는 생각으로 풀었다.
## 나이순 정렬
### 문제
- 온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 
- 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성하시오.
### 입력
- 첫째 줄에 회원 수 N
- 둘째 줄부터 N개의 줄에는 각 회원의 나이와 이름이 공백으로 구분되어 주어짐
- 1 <= 나이 <= 200
- 이름은 알파벳 대소문자, 1 <= 이름 길이 <= 100
### 출력
- 첫째 줄부터 N개의 죽까지 회원을 나이 순, 나이가 같으면 가입한 순으로 출력
### 예제 입력 1
```
3
21 Junkyu
21 Dohyun
20 Sunyoung

```
### 예제 출력 1

```
20 Sunyoung
21 Junkyu
21 Dohyun
```
## 좌표 압축
### 문제
- 수직선 위에 N개의 좌표 X1,X2,...,XN
- Xi를 좌표 압축한 결과 X'i의 값은 Xi > Xj를 만족하는 서로 다른 좌표 Xj의 개수와 같아야 한다.
- X1,X2,...,XN의 압축 결과인 X'1,X'2,...,X'N을 출력 
### 입력
- 첫째 줄에 N이 주어짐
- 둘째 줄에 공백 한 칸으로 구분된 X1,X2,...XN이 주어짐
### 출력
- 첫째 줄에 X'1,X'2,...,X'N을 출력
### 제한
- 1 ≤ N ≤ 1,000,000
- 10^9 ≤ Xi ≤ 10^9
### 예제 입력 1
```
5
2 4 -10 4 -9
```

### 예제 출력 1
```
2 3 0 3 1
```

### 예제 입력 2
```
6
1000 999 1000 999 1000 999
```

### 예제 출력 2
```
1 0 1 0 1 0
```
### 접근 방식
- 입력값에서 중복된 값을 제외하며 정렬한 새로운 배열을 생성
- 새로운 배열의 인덱스가 그 값보다 더 작은 수의 갯수를 의미
    - [2,4,-10,4,-9] -> [-10,-9,2,4] 
- 새로운 배열과 기존 배열을 비교하며 일치하면 인덱스를 저장
    - [2,3,0,3,1]
- 시간초과 때문에 반복문 대신 set을 사용해 중복값을 처리하였고 딕셔너리에 값을 저장하여 문제를 풀였다
- 시간초과 개시름
### 풀이 코드
```
N = int(input())
arr = list(map(int,input().split()))
sort_arr = sorted(arr)

for i in range(len(sort_arr) -1,0,-1):
    if sort_arr[i] == sort_arr[i-1]:
        sort_arr.remove(sort_arr[i])

for i in range(len(arr)):
    for j in range(len(sort_arr)):
        if arr[i] == sort_arr[j]:
            arr[i] = j

print(arr)
```
- 시간 초과 발생 remove 사용과 이중 for문이 문제일 듯
- set과 딕셔너리를 사용해서 해결

## 파일명 정렬
- 이름순으로 정렬된 파일을 숫자순으로 변경
- 파일명은 100글자 이내로, 영문 대소문자, 숫자, 공백(" "), 마침표("."),빼기 부호("-")만으로 이루어져 있다
- 파일명은 영문자로 시작, 숫자를 하나 이상 포함하며 HEAD, NUMBER, TAIL의 세 부분으로 구성
    - HEAD는 숫자가 아닌 문자, 최소한 한 글자 이상
    - NUMBER는 한 글자에서 최대 다섯 글자 사이의 연속된 숫자, 앞쪽에 0이 올 수 있다. 0부터 99999 사이의 숫자로, 00000이나 0101 등도 가능하다
    - TAIL은 그 나머지 부분으로, 여기에는 숫자가 다시 나타날 수도 있으며, 아무 글자도 없을 수 있다.
    | 파일명 | HEAD | NUMBER | TAIL |
    | --- | --- | --- | --- |
    | foo9.txt | foo | 9 | .txt |
    | foo010bar020.zip | foo | 010 | bar020.zip |
    | F-15 | F- | 15 | (빈 문자열) |
    
파일명을 세 부분으로 나눈 후, 다음 기준에 따라 파일명을 정렬한다.

- 파일명은 우선 HEAD 부분을 기준으로 사전 순으로 정렬한다. 이때, 문자열 비교 시 대소문자 구분을 하지 않는다. `MUZI`와 `muzi`, `MuZi`는 정렬 시에 같은 순서로 취급된다.
- 파일명의 HEAD 부분이 대소문자 차이 외에는 같을 경우, NUMBER의 숫자 순으로 정렬한다. 9 < 10 < 0011 < 012 < 13 < 014 순으로 정렬된다. 숫자 앞의 0은 무시되며, 012와 12는 정렬 시에 같은 같은 값으로 처리된다.
- 두 파일의 HEAD 부분과, NUMBER의 숫자도 같을 경우, 원래 입력에 주어진 순서를 유지한다. `MUZI01.zip`과 `muzi1.png`가 입력으로 들어오면, 정렬 후에도 입력 시 주어진 두 파일의 순서가 바뀌어서는 안 된다.

무지를 도와 파일명 정렬 프로그램을 구현하라.

### 입력

입력으로 배열 `files`가 주어진다.

- `files`는 1000 개 이하의 파일명을 포함하는 문자열 배열이다.
- 각 파일명은 100 글자 이하 길이로, 영문 대소문자, 숫자, 공백(" "), 마침표("."), 빼기 부호("-")만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다.
- 중복된 파일명은 없으나, 대소문자나 숫자 앞부분의 0 차이가 있는 경우는 함께 주어질 수 있다. (`muzi1.txt`, `MUZI1.txt`, `muzi001.txt`, `muzi1.TXT`는 함께 입력으로 주어질 수 있다.)

### 출력

위 기준에 따라 정렬된 배열을 출력한다.

### 입출력 예제

입력: ["img12.png", "img10.png", "img02.png", "img1.png", "IMG01.GIF", "img2.JPG"]

출력: ["img1.png", "IMG01.GIF", "img02.png", "img2.JPG", "img10.png", "img12.png"]

입력: ["F-5 Freedom Fighter", "B-50 Superfortress", "A-10 Thunderbolt II", "F-14 Tomcat"]

출력: ["A-10 Thunderbolt II", "B-50 Superfortress", "F-5 Freedom Fighter", "F-14 Tomcat"]

### 문제 접근
- files 배열의 값을 head, number, tail로 분할
- 검색해보니 re 라이브러리로 할 수 있었음 
- 먼저 숫자로 분할해보았다
    - num += re.findall(r'\d+',files[i]) 이렇게 하니까 숫자만 추출 가능
    - num = sorted(num, key=int) -> 1, 01 입력 순서 그대로 있게 가능
- re.match를 사용해서 Head(숫자가 아닌 문자 '\D') , Number(1~5자리 숫자 '\d{1,5}'), Tail(숫자 혹은 문자)로 나눠서 저장
- 일단 Number를 key = int로 정렬하고 Head를 정렬했음
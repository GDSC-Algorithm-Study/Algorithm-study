## DFS와 BFS
### 문제
- 그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성
- 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더이상 방문이 안되면 종료
### 입력
- 첫째 줄 정점의 개수 N(1이상 1000이하), 간선의 개수 M(1이상 10000이하), 탐색을 시작할 정점의 번호 V
- 다음 M개의 줄에 간선이 연결하는 두 정점의 번호가 주어짐
### 출력
- 첫째 줄에 DFS의 결과
- 그 다음 줄에 BFS를 수행한 결과
- V부터 방문된 점을 순서대로 출력
### 문제 풀이
- 그래프를 만들어서 각각 나눠서 dfs, bfs를 실행
- dfs는 재귀함수로 , bfs는 큐로 구현

## 숨바꼭질 2
### 문제
- 수빈 위치: N(0 이상 100,000 이하), 동생 위치: K(0 이상 100,000 이하)
- 수빈이는 걷거나 순간이동이 가능 
    - 걸을 때는 1초 후에 `X-1` <- `X` -> `X+1`
    - 순간이동 할 때는 1초 후에 `2*X`의 위치로 이동
- 수빈과 동생의 위치가 주어졌을 때 수빈이가 동생을 찾을 수 있는 최단 시간과 그 방법의 가지 수를 구해라
### 입력
- 첫 번째 줄에 N,K
### 출력
- 첫 째줄 빠른 시간 둘째 줄 방법의 수
### 문제 풀이
- 5이면 4, 8, 16, 17 이렇게 4초 걸리는게 최소
- 최단 거리를 찾는 문제이므로 BFS를 사용
- 위치와 시간을 동시에 `deque`에 저장하는 것으로 bfs를 시작
- 처음 방문 위치는 수빈이 위치 최소 시간은 None으로 초기화
- X가 K가 되는 순간에 min_time이 None이면(처음) min_time = time이고 count를 1 추가
- x-1,x+1,2*x를 반복하는 for문을 구현 이때 방문하지 않은 인덱스 이거나 방문하였지만 시간값이 더 빠르거나 같다면 현재 시간값을 변화시켜준다
### 문제 회고
<aside>
이전부터 생각했던 것이지만 탐색 문제에 유독 약한 것 같다. 앞선 문제도 풀었던 문제이지만 어렵게 풀었고 이 문제는 답을 출력한 뒤에도 몇 번씩 더 확인한 거 같고...평소 공부할 때도 이 알고리즘 문제는 회피하면서 잘 안풀기도 했던 것을 반성하게 되었다. 
</aside>

## 거리두기 확인하기
### 문제
- 대기실은 5개, 각 대기실의 크기는 5*5
- 거리두기를 위해서 응시자들 끼리는 맨해튼 거리가 2이하로 앉지 말아라
    - 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면, T1, T2 사이의 맨해튼 거리는 `|r1 - r2|` + `|c1 - c2|` 입니다.
- 단, 파티션으로 막혀있으면 허용
- 응시자의 위치: `P`, 빈 테이블: `0`, 파티션: `X`
- 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 `places`가 매개변수로 주어집니다.
- 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성해 주세요.

<aside>
💡 제한사항

- `places`의 행 길이(대기실 개수) = 5
    - `places`의 각 행은 하나의 대기실 구조를 나타냅니다.
- `places`의 열 길이(대기실 세로 길이) = 5
- `places`의 원소는 `P`,`O`,`X`로 이루어진 문자열입니다.
    - `places` 원소의 길이(대기실 가로 길이) = 5
    - `P`는 응시자가 앉아있는 자리를 의미합니다.
    - `O`는 빈 테이블을 의미합니다.
    - `X`는 파티션을 의미합니다.
- 입력으로 주어지는 5개 대기실의 크기는 모두 5x5 입니다.
- return 값 형식
    - 1차원 정수 배열에 5개의 원소를 담아서 return 합니다.
    - `places`에 담겨 있는 5개 대기실의 순서대로, 거리두기 준수 여부를 차례대로 배열에 담습니다.
    - 각 대기실 별로 모든 응시자가 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 담습니다.
</aside>

### 입출력 예
| places | result |
| --- | --- |
| [["POOOP", "OXXOX", "OPXPX", "OOXOX", "POXXP"], ["POOPX", "OXPXP", "PXXXO", "OXXXO", "OOOPP"], ["PXOPX", "OXOXP", "OXPOX", "OXXOP", "PXPOX"], ["OOOXX", "XOOOX", "OOOXX", "OXOOX", "OOOOO"], ["PXPXP", "XPXPX", "PXPXP", "XPXPX", "PXPXP"]] | [1, 0, 1, 1, 1] |

### 문제 접근
- 탐색 문제니까 어떤 탐색을 사용할지 먼저 고려해보자
- 5 * 5의 강의실을 5번 탐색하게 될 것이기에 시간 복잡도의 고려는 하지 않아도 될 듯
- P의 상하좌우를 고려
- P와 P의 거리 상으로 가까울 때 X의 유무를 고려
- 하나라도 거리두기가 제대로 이루어지지 않는다면 탐색을 종료
- dfs, bfs 둘 다 사용해서 구현해보도록 하겠다.
- P 들의 위치를 찾는 것으로 풀이를 시작해보자아아..

## DFS와 BFS
### 문제
- 그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성
- 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더이상 방문이 안되면 종료
### 입력
- 첫째 줄 정점의 개수 N(1이상 1000이하), 간선의 개수 M(1이상 10000이하), 탐색을 시작할 정점의 번호 V
- 다음 M개의 줄에 간선이 연결하는 두 정점의 번호가 주어짐
### 출력
- 첫째 줄에 DFS의 결과
- 그 다음 줄에 BFS를 수행한 결과
- V부터 방문된 점을 순서대로 출력
### 문제 풀이
- 그래프를 만들어서 각각 나눠서 dfs, bfs를 실행
- dfs는 재귀함수로 , bfs는 큐로 구현

## 숨바꼭질 2
### 문제
- 수빈 위치: N(0 이상 100,000 이하), 동생 위치: K(0 이상 100,000 이하)
- 수빈이는 걷거나 순간이동이 가능 
    - 걸을 때는 1초 후에 X-1 <- X -> X+1
    - 순간이동 할 때는 1초 후에 2*X의 위치로 이동
- 수빈과 동생의 위치가 주어졌을 때 수빈이가 동생을 찾을 수 있는 최단 시간과 그 방법의 가지 수를 구해라
### 입력
- 첫 번째 줄에 N,K
### 출력
- 첫 째줄 빠른 시간 둘째 줄 방법의 수
### 문제 풀이
- 5이면 4, 8, 16, 17 이렇게 4초 걸리는게 최소
- 최단 거리를 찾는 문제이므로 BFS를 사용
- 위치와 시간을 동시에 deque에 저장하는 것으로 bfs를 시작
- 처음 방문 위치는 수빈이 위치 최소 시간은 None으로 초기화
- X가 K가 되는 순간에 min_time이 None이면(처음) min_time = time이고 count를 1 추가
- x-1,x+1,2*x를 반복하는 for문을 구현 이때 방문하지 않은 인덱스 이거나 방문하였지만 시간값이 더 빠르거나 같다면 현재 시간값을 변화시켜준다
### 문제 회고
<aside>
💡 문제 회고

이전부터 생각했던 것이지만 탐색 문제에 유독 약한 것 같다. 앞선 문제도 풀었던 문제이지만 어렵게 풀었고 이 문제는 답을 출력한 뒤에도 몇 번씩 더 확인한 거 같고...평소 공부할 때도 이 알고리즘 문제는 회피하면서 잘 안풀기도 했던 나를 반성하게 되었다. 

</aside>